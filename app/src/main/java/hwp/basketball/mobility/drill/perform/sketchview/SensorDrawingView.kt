package hwp.basketball.mobility.pathrecorder.sketchview

import android.content.Context
import android.graphics.*
import android.graphics.Paint.Style
import android.hardware.SensorManager.GRAVITY_EARTH
import android.util.AttributeSet
import android.view.View
import android.widget.Toast
import hwp.basketball.mobility.R
import hwp.basketball.mobility.device.sensor.BMSensorManager
import hwp.basketball.mobility.device.sensor.IBMSensorManager
import hwp.basketball.mobility.drillpreparation.step.DrillSetupOutput
import hwp.basketball.mobility.entitiy.drills.ViewDimens
import hwp.basketball.mobility.pathrecorder.sketchview.Movement.Move
import hwp.basketball.mobility.util.*
import hwp.basketball.mobility.util.PointF
import hwp.basketball.mobility.view.CompassView
import timber.log.Timber
import java.util.concurrent.ConcurrentLinkedQueue
import kotlin.streams.toList


class SensorDrawingView : View, SensorDrawingViewViewContract.View {

    /**Array (for each axis value) of moving average windows
     *
     * Used for averaging acceleration values after removing gravity.
     *
     * Note: values kept here are in mG. before applying some math to it make sure
     * to convert to m/s^2
     * */
    val movingAverageLinearAcc = Array(3, { MovingAverage(30, 20) })

    /**Previously read timestamp*/
    var mPrevReadingTimestamp: Long = -1

    /**Current speed.
     * Should be im m/s but not quite true.*/
    var v0: Double = 0.0

    /**
     * Current magnitude of linear acceleration in m/s.*/
    var a: Float = 0.0f

    /**
     * List of moves generated by */
    val accBasedMoves: ConcurrentLinkedQueue<Move> = ConcurrentLinkedQueue()

    /*Variables for dealing with reading acceleration and calculating gravity.*/
    internal var gravity = FloatArray(3)

    internal var linear_acceleration = IntArray(3)
    internal var accReading: Short = 0
    internal val alpha = 0.9f

    var startPoint = PointF()

    var actualEndPoint = PointF()

    /**Distance of the current location from the desired path.
     * Used for detecting when user is off the path*/
    var currentDistanceFromDesiredPath: Double = 0.0

    /**
     * Path generated by using values from sensor.*/
    var sensorPath: Path = Path()

    var offDesiredPath: Path = Path()

    /**
     * Path generated using drill creation interface.
     * Generated by coach and passed as a parameter to this view.*/
    val desiredPath: Path by lazy {
        val path = Path()
        if (pathViewPoints.isNotEmpty()) {
            path.moveTo(pathViewPoints[0])
            for (i in 1..pathViewPoints.size - 1) {
                path.lineTo(pathViewPoints[i])
            }
        }
        initBeforeDrillStart()
        path
    }

    companion object {
        var ACC_MULTIPLIER = 0.4f
        var ANGLE_DIFF_CUTOFF = 0.75
        var MIN_SPEED = 0.00f

        fun setAngleDiff(angle: Double) {
            synchronized(ANGLE_DIFF_CUTOFF, { ANGLE_DIFF_CUTOFF = angle })
        }

        fun setMultiplier(multiplier: Float) {
            synchronized(ACC_MULTIPLIER, { ACC_MULTIPLIER = multiplier })
        }

        fun setMinSpeed(speed: Float) {
            synchronized(MIN_SPEED, { MIN_SPEED = speed })
        }

        val PATH_WIDTH_IN_PIXELS = 5
        val CURRENT_LOCATION_RADIUS_PIXELS = PATH_WIDTH_IN_PIXELS * 1.6f
        val DESIRED_PATH_COLOR = Color.BLUE
        val SENSOR_PATH_COLOR = Color.GREEN
    }


    val viewDimens: ViewDimens by lazy {
        ViewDimens(width, height)
    }

    val pathViewPoints: List<PointF> by lazy {
        /**
         * Converting path points received in percentage on screen to actual screen points.
         * Note that here we handle multiple resolution/densities screens.
         */
        val drill = DrillSetupOutput.drill ?: throw IllegalStateException("Drill cannot be null here")
        drill.pathPoints
                .stream()
                .map { it.toViewPoint(viewDimens) }
                .toList()
    }

//    var segmentDesiredOrientation: FloatArray = 0f

    val pathSegmentsLengths: List<Pair<Float, Double>> by lazy {
        val list = mutableListOf<Pair<Float, Double>>()
        val len = getAngleLengthForSegmentIndex(0, 0F)
        list.add(len)
        for (i in 1..pathViewPoints.size - 2) {
            val lengthForSegmentIndex = getAngleLengthForSegmentIndex(i, list[i - 1].first)
            list.add(lengthForSegmentIndex)
        }
        list
    }

    fun getAngleLengthForSegmentIndex(i: Int, previousLength: Float): Pair<Float, Double> {
        val path = Path()
        val start = pathViewPoints[i]
        val end = pathViewPoints[i + 1]
        path.moveTo(start)
        path.lineTo(end)
        val angle = end.getAngle(start)
        return Pair(PathMeasure(path, false).length + previousLength, angle)
    }

    fun initBeforeDrillStart() {
        pathViewPoints[0].let {
            startPoint = it
            actualEndPoint = it
            accBasedMoves.add(Move(direction = 0f, distance = 0f))
            sensorPath.moveTo(startPoint)
        }
    }

    /**Variable for measuring how far user got on the desired path.*/
    val pathMeasure: PathMeasure by lazy {
        PathMeasure(desiredPath, false)
    }

    val pathLength by lazy {
        pathMeasure.length
    }
    /**Distance covered by player (in pixels).*/
    var distanceCovered: Float = 0f

    /**Destination path to be written to when using PathMeasure get segment method.*/

    /**List to be used for informing UI about debug data.*/
    val listDebugMessages = arrayListOf<String>()

    //path paint
    var paintDesiredPath: Paint = Paint()
    var paintSensorPath: Paint = Paint()
    var paintCurrentLocation: Paint = Paint()
    var paintArea: Paint = Paint()

    lateinit var courtBackGround: Bitmap

    fun InitSketch() {
        paintDesiredPath.color = DESIRED_PATH_COLOR
        paintDesiredPath.strokeWidth = PATH_WIDTH_IN_PIXELS.toFloat()
        paintDesiredPath.style = Style.STROKE
        paintDesiredPath.isAntiAlias = true

        paintSensorPath.color = SENSOR_PATH_COLOR
        paintSensorPath.strokeWidth = PATH_WIDTH_IN_PIXELS.toFloat()
        paintSensorPath.style = Style.STROKE
        paintSensorPath.isAntiAlias = true

        paintCurrentLocation.color = 0xFF00FF55.toInt()
        paintCurrentLocation.strokeWidth = 2f
        paintCurrentLocation.style = Style.FILL
        paintCurrentLocation.isAntiAlias = true

        courtBackGround = BitmapFactory.decodeResource(context.resources, R.drawable.halfcourt2)

        paintArea.color = Color.RED
        paintArea.strokeWidth = 2f
        paintArea.style = Style.FILL
        paintArea.isAntiAlias = true
    }

    override fun getBitmap(): Bitmap {
        val conf = Bitmap.Config.RGB_565
        val bitmap = Bitmap.createBitmap(width, height, conf)
        draw(Canvas(bitmap))
//        bitmap.recycle()
        return bitmap
    }

    override fun getBitmapArea(): Bitmap {
        val conf = Bitmap.Config.RGB_565
        val bitmap = Bitmap.createBitmap(width, height, conf)
        val canvas = Canvas(bitmap)
        drawBackground(canvas)
        canvas.drawPath(sensorPath, paintSensorPath)
        canvas.drawPath(desiredPath, paintDesiredPath)
        canvas.drawPath(offDesiredPath, paintArea)
//        bitmap.recycle()
        return bitmap
    }

    override fun getDesiredPathLength(): Float = pathLength

    constructor(context: Context) : super(context) {
        InitSketch()
    }

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        InitSketch()
    }

    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {
        InitSketch()
    }

    override fun onSensorDisconnected(bmSensorManager: IBMSensorManager) {
        showToastMessage("Disconnected from: " + bmSensorManager)
    }

    override fun onSensorConnected(bmSensorManager: IBMSensorManager) {
        showToastMessage("Connected to: " + bmSensorManager)
    }

    lateinit var mPresenter: SensorDrawingViewViewContract.Presenter

    override fun setPresenter(sensorDrawingViewPresenter: SensorDrawingViewViewContract.Presenter) {
        this.mPresenter = sensorDrawingViewPresenter
    }

    override fun showToastMessage(message: String) {
        this.post { Toast.makeText(context, message, Toast.LENGTH_SHORT).show() }
    }

    var isMoving: Boolean = false

    override fun setIsMoving(isMoving: Boolean) {
        this.isMoving = isMoving
    }

    override fun setDegreesToNorth(degreesToTrueNorth: Float) {
        compassView.updateAngle(degreesToTrueNorth)
    }

    override fun invalidateView() {
        this.post {
            invalidate()
        }
    }

    fun setAspectRatio(aspectRatio: Float) {
        compassView.screenAspectRatio = aspectRatio
    }

    fun getStatistics(): ArrayList<String> {
        listDebugMessages.clear()
        listDebugMessages.add("Distance from desired path: $currentDistanceFromDesiredPath")
        listDebugMessages.add("Linear Speed (magnitude) (m/s): $v0")
        listDebugMessages.add("Linear acc (magnitude) (m/s2): $a")
        listDebugMessages.add("Degree diff (avg): ${Math.abs(compassView.movingAverageAngleDiff.avg)}")
        listDebugMessages.add("Is rotating: ${compassView.isRotating()}")
        listDebugMessages.add("Is moving: $isMoving")
        return listDebugMessages

    }

    fun drawBackground(canvas: Canvas) {
        //TODO deal with aspect ratio --> image gets distorted
        val rectSrc = Rect(0, 0, courtBackGround.width, courtBackGround.height)
        val rectDst = Rect(0, 0, canvas.width, canvas.height)
        canvas.drawBitmap(courtBackGround, rectSrc, rectDst, null)
    }


    val compassView: CompassView by lazy {
        CompassView(context)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        drawBackground(canvas)

        if (ViewUtils.isInDebugMode) {
            mPresenter.displayStats(getStatistics())
        }

        updateCurrentSegmentValues()

        compassView.drawCompass(canvas)

        canvas.drawPath(desiredPath, paintDesiredPath)

        if (isMoving) {
            updateSensorPath()
        }


        canvas.drawPath(sensorPath, paintSensorPath)
        canvas.drawCircle(actualEndPoint, CURRENT_LOCATION_RADIUS_PIXELS, paintCurrentLocation)
    }

    var isOffThePath = false
    var currentSegmentIndex: Int = 0
    var currentSegmentAngle: Double = 0.0


    private var isInRecordingMode: Boolean = false

    override fun onRecordingModeChange(inRecordingMode: Boolean) {
        isInRecordingMode = inRecordingMode
    }

    fun updateSensorPath() {

        if (currentSegmentIndex > pathSegmentsLengths.size - 1) {
            if (isInRecordingMode) {
                mPresenter.onDrillCompleted()
            }
            return
        }

        actualEndPoint = Movement.getNextDrawPoint(actualEndPoint, accBasedMoves.last())

        if (currentDistanceFromDesiredPath > 20) {
            sensorPath.lineTo(actualEndPoint)

            if (!isOffThePath) {
                val currentDesiredPathEnd = PointF()
                pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
                offDesiredPath.moveTo(currentDesiredPathEnd)
            } else {
                offDesiredPath.lineTo(actualEndPoint)
            }

            isOffThePath = true
        } else {
            if (isOffThePath) {
                isOffThePath = false
                val currentDesiredPathEnd = PointF()
                pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
                val currentPathEnd = PointF(actualEndPoint.x, actualEndPoint.y)
                val angle = Vector2D.angleBetweenTwoVectorsInRad(currentDesiredPathEnd, currentPathEnd)
                val dist = Math.cos(angle) * Vector2D.distance(currentDesiredPathEnd, currentPathEnd)
                Timber.d("coming to the path: $angle, dist: $dist")

                distanceCovered += dist.toInt()
                pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
                sensorPath.lineTo(currentDesiredPathEnd)
                offDesiredPath.lineTo(currentDesiredPathEnd)
            } else {
                val distance = accBasedMoves.last().distance
                val nextPoint = PointF()
                val isPosExtracted = pathMeasure.getPointAtDistance(distanceCovered + distance, nextPoint)
                val isHeadingRightDirection =
                        compassView.degreesToNorth in (currentSegmentAngle - 10)..(currentSegmentAngle + 10)
                Timber.d("${compassView.degreesToNorth} <- compass current ->  $currentSegmentAngle correction ${compassView}")
                if (isPosExtracted && isHeadingRightDirection) {
                    sensorPath.lineTo(nextPoint)
                    distanceCovered += distance
                }
            }
        }

        currentDistanceFromDesiredPath = Geometry2D.distance(pathViewPoints, actualEndPoint, currentSegmentIndex)
    }

    fun updateCurrentSegmentValues() {
        pathSegmentsLengths.forEachIndexed { index, (length, angle) ->
            if (distanceCovered < length) {
                currentSegmentIndex = index
                currentSegmentAngle = angle
                return
            }
        }
        currentSegmentIndex = pathSegmentsLengths.size
    }

    override fun resetDrill() {
        movingAverageLinearAcc.forEach { it.reset() }

        mPrevReadingTimestamp = -1
        v0 = 0.0
        a = 0F
        distanceCovered = 0F
        currentDistanceFromDesiredPath = 0.0
        accBasedMoves.clear()
        sensorPath.reset()
        offDesiredPath.reset()

        initBeforeDrillStart()
    }

    fun calculateLinearAccAndGravity(sample: BMSensorManager.AccData) {
        for (i in 0..2) {
            accReading = sample.data[i].toShort()
            gravity[i] = alpha * gravity[i] + (1 - alpha) * accReading

            val nextMAValue = if (compassView.isRotating()) 0 else (accReading - gravity[i]).toInt()
            val avg = movingAverageLinearAcc[i].next(nextMAValue)
            linear_acceleration[i] = avg.toInt()
        }
    }

    override fun addAccData(accData: BMSensorManager.AccData) {
        if (mPrevReadingTimestamp == -1L) {
            mPrevReadingTimestamp = accData.timestamp
            return
        }

        val dt = (accData.timestamp - mPrevReadingTimestamp).toDouble() / 100

        calculateLinearAccAndGravity(accData)

        val squaresSumLinearAcc = (0..2)
                .map { linear_acceleration[it] / 1000f }
                .sumByDouble { (it * it).toDouble() }

        a = GRAVITY_EARTH * Math.sqrt(squaresSumLinearAcc).toFloat()

        val s = v0 * dt + a * dt * dt / 2
        if (isMoving && !compassView.isRotating()) {
            val pixelDistance = ViewUtils.convertMetersToPixels(s.toFloat())
            accBasedMoves.add(Move(compassView.degreesToNorth, ACC_MULTIPLIER * pixelDistance))
        } else {
            v0 = 0.0
            a = 0f
        }
        v0 += a * dt

        mPrevReadingTimestamp = accData.timestamp
    }
}
