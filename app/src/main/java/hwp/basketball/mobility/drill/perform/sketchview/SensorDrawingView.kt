package hwp.basketball.mobility.drill.perform.sketchview

import android.content.Context
import android.graphics.*
import android.graphics.Paint.Style
import android.hardware.SensorManager.GRAVITY_EARTH
import android.util.AttributeSet
import android.view.View
import android.widget.Toast
import hwp.basketball.mobility.R
import hwp.basketball.mobility.device.sensor.BMSensorManager
import hwp.basketball.mobility.device.sensor.IBMSensorManager
import hwp.basketball.mobility.drillpreparation.step.DrillSetupOutput
import hwp.basketball.mobility.entitiy.drills.ViewDimens
import hwp.basketball.mobility.util.*
import hwp.basketball.mobility.util.PointF
import hwp.basketball.mobility.view.CompassView
import io.reactivex.disposables.Disposable
import timber.log.Timber
import java.util.concurrent.ConcurrentLinkedQueue
import kotlin.properties.Delegates

/**
 * Custom view made for the purpose of drawing sensor generated path on top of
 * basketball field bitmap.
 **/
class SensorDrawingView : View, SensorDrawingViewViewContract.View {

    /**Array (for each axis value) of moving average windows
     *
     * Used for averaging acceleration values after removing gravity.
     *
     * Note: values kept here are in mG. before applying some math to it make sure
     * to convert to m/s^2
     * */
    val movingAverageLinearAcc = Array(3, { MovingAverage(30, 20) })

    /**Previously read timestamp*/
    var mPrevReadingTimestamp: Long = -1

    /**Current speed.
     * Should be im m/s but not quite true.*/
    var v0: Double = 0.0

    /**
     * Current magnitude of linear acceleration in m/s.*/
    var a: Float = 0.0f

    /**
     * List of moves generated by sensor data.
     * This list of moves is used in each frame to draw path.
     * */
    val accBasedMoves: ConcurrentLinkedQueue<Move> = ConcurrentLinkedQueue()

    /*Variables for dealing with reading acceleration and calculating gravity.*/
    internal var gravity = FloatArray(3)

    /** Current linear acceleration values per each axis*/
    internal var linear_acceleration = IntArray(3)
    /** @suppress*/
    internal var accReading: Short = 0
    /** Low pass filter value used for gravity compensation*/
    internal val alpha = 0.9f
    /**Current position of the player on the screen.
     * End of the current path. */
    var actualEndPoint = PointF()

    /**Distance of the current location from the desired path.
     * Used for detecting when user is off the path*/
    var currentDistanceFromDesiredPath: Double by Delegates.observable(0.0, { prop, old, new ->
        if (isMoving) {
            updateIsOffThePath(new)
        }
    })

    private fun updateIsOffThePath(distanceFromDesiredPath: Double) {
        val tempIsOffThePath = distanceFromDesiredPath > DISTANCE_FROM_DESIRED_PATH_TOLERANCE
        if (!tempIsOffThePath && isOffThePath) {
            //means that we are coming back to path
            val currentDesiredPathEnd = PointF()
            pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
            val angle = currentDesiredPathEnd.getAngle(actualEndPoint)
            val isInFrontOfLastDesired = (angle - currentSegmentAngle) in (-90)..90
//            Timber.d("isInFrontOfLastDesired: $isInFrontOfLastDesired, angle: $angle, " +
//                    "currentSegmentAngle: $currentSegmentAngle")
            if (!isInFrontOfLastDesired || distanceFromDesiredPath > COMING_BACK_TO_PATH_TOLERANCE) {
                return
            }
        }
        isOffThePath = tempIsOffThePath
    }

    /**
     * Path generated by using values from sensor.*/
    var sensorPath: Path = Path()

    /**
     * Path being drawn when user goes of the desired path.
     * */
    var offDesiredPath: Path = Path()

    /**
     * Path generated using drill creation interface.
     * Generated by coach and passed as a parameter to this view.*/
    val desiredPath: Path by lazy {
        val path = Path()
        if (pathViewPoints.isNotEmpty()) {
            path.moveTo(pathViewPoints[0])
            for (i in 1..pathViewPoints.size - 1) {
                path.lineTo(pathViewPoints[i])
            }
        }
        initBeforeDrillStart()
        path
    }

    /** @suppress Used for debug purposes only*/
    companion object {
        var ACC_MULTIPLIER = 0.4f
        var ANGLE_DIFF_CUTOFF = 0.75
        var MIN_SPEED = 0.00f

        fun setAngleDiff(angle: Double) {
            synchronized(ANGLE_DIFF_CUTOFF, { ANGLE_DIFF_CUTOFF = angle })
        }

        fun setMultiplier(multiplier: Float) {
            synchronized(ACC_MULTIPLIER, { ACC_MULTIPLIER = multiplier })
        }

        fun setMinSpeed(speed: Float) {
            synchronized(MIN_SPEED, { MIN_SPEED = speed })
        }

        val PATH_WIDTH_IN_PIXELS = 10
        val CURRENT_LOCATION_RADIUS_PIXELS = PATH_WIDTH_IN_PIXELS * 1.6f
        val DESIRED_PATH_COLOR = Color.BLUE
        val SENSOR_PATH_COLOR = Color.GREEN
        val DISTANCE_FROM_DESIRED_PATH_TOLERANCE = 20
        val COMING_BACK_TO_PATH_TOLERANCE = 5
        val VIEW_PADDING = 20
        val OUT_OF_BOUNDS_POINT = PointF(-1f, -1f)
    }


    /**
     * Current displayed view dimensions.
     * This dimensions are handling different view sizes per layout design or diferrent resolution.
     * These values are going to be different
     * for different screens based on resolution.
     *
     * It's using lazy delegate for initialization.
     * */
    val viewDimens: ViewDimens by lazy {
        ViewDimens(width, height)
    }

    /**
     * Converted path points received in percentage on screen to actual screen points.
     * Note that here we handle multiple resolution/densities screens.
     *
     * It's using lazy delegate for initialization.
     */
    val pathViewPoints: List<PointF> by lazy {
        val drill = DrillSetupOutput.drill ?: throw IllegalStateException("Drill cannot be null here")
        drill.pathPoints
                .map { it.toViewPoint(viewDimens) }
                .toList()
    }

    /**
     * List used for saving segment end distance (on the path)
     * and desired angle of each segment on the path.
     *
     * It's using lazy delegate for initialization.
     * */
    val pathSegmentsLengths: List<Pair<Float, Double>> by lazy {
        val list = mutableListOf<Pair<Float, Double>>()
        val len = getAngleLengthForSegmentIndex(0, 0F)
        list.add(len)
        for (i in 1..pathViewPoints.size - 2) {
            val lengthForSegmentIndex = getAngleLengthForSegmentIndex(i, list[i - 1].first)
            list.add(lengthForSegmentIndex)
        }
        list
    }

    /**
     * Method used for calculating distance on path where current segment ends, and angle.
     * Then returns those values as a pair.
     *
     * @param i index of the Start point. It is assumed that each segmen ends at next point.
     * @param previousLength Length of the previous segment.
     * @return Calculated (endDistance, angle) pair for current segment. Length is cumulative, meaning
     * */
    fun getAngleLengthForSegmentIndex(i: Int, previousLength: Float): Pair<Float, Double> {
        val path = Path()
        val start = pathViewPoints[i]
        val end = pathViewPoints[i + 1]
        path.moveTo(start)
        path.lineTo(end)
        val angle = start.getAngle(end)
        return Pair(PathMeasure(path, false).length + previousLength, angle)
    }

    /**Initializing sensor path and setting other initial values.*/
    fun initBeforeDrillStart() {
        pathViewPoints[0].let { firstPathViewPoint ->
            actualEndPoint = firstPathViewPoint
            accBasedMoves.add(Move(direction = 0f, distance = 0f))
            sensorPath.moveTo(firstPathViewPoint)
        }
    }

    /**Variable for measuring how far user got on the desired path.*/
    val pathMeasure: PathMeasure by lazy {
        PathMeasure(desiredPath, false)
    }

    /**Property keeping the desired path length. Used to determine end of the drill.*/
    val pathLength by lazy {
        pathMeasure.length
    }
    /**Distance covered by player (in pixels).*/
    var distanceCovered: Float = 0f

    /**List to be used for informing UI about debug data.*/
    val listDebugMessages = arrayListOf<String>()

    var paintDesiredPath: Paint = Paint()
    var paintSensorPath: Paint = Paint()
    var paintCurrentLocation: Paint = Paint()
    var paintArea: Paint = Paint()

    lateinit var courtBackGround: Bitmap

    /** Initializing paints used for drawing.*/
    fun initDrawingView() {
        paintDesiredPath.color = DESIRED_PATH_COLOR
        paintDesiredPath.strokeWidth = PATH_WIDTH_IN_PIXELS.toFloat()
        paintDesiredPath.style = Style.STROKE
        paintDesiredPath.isAntiAlias = true

        paintSensorPath.color = SENSOR_PATH_COLOR
        paintSensorPath.strokeWidth = PATH_WIDTH_IN_PIXELS.toFloat()
        paintSensorPath.style = Style.STROKE
        paintSensorPath.isAntiAlias = true

        paintCurrentLocation.color = 0xFF00FF55.toInt()
        paintCurrentLocation.strokeWidth = 2f
        paintCurrentLocation.style = Style.FILL
        paintCurrentLocation.isAntiAlias = true

        courtBackGround = BitmapFactory.decodeResource(context.resources, R.drawable.halfcourt2)

        paintArea.color = Color.RED
        paintArea.strokeWidth = 2f
        paintArea.style = Style.FILL
        paintArea.isAntiAlias = true
    }

    /** Method for exporting drill bitmap.
     *
     * @return current drill's Bitmap
     * */
    override fun getBitmap(): Bitmap {
        val conf = Bitmap.Config.RGB_565
        val bitmap = Bitmap.createBitmap(width, height, conf)
        draw(Canvas(bitmap))
        return bitmap
    }

    /**
     * Method for exporting area bitmap.
     * This method is crucial for generating area bitmap which is used to calculate
     * quality of the drill based on the area generated.
     *
     * Area should be as small as possible for the outcome to be better.
     *
     * @return current errorArea bitmap marked in red.
     * */
    override fun getBitmapArea(): Bitmap {
        val conf = Bitmap.Config.RGB_565
        val bitmap = Bitmap.createBitmap(width, height, conf)
        val canvas = Canvas(bitmap)
        drawBackground(canvas)
        canvas.drawPath(sensorPath, paintSensorPath)
        canvas.drawPath(desiredPath, paintDesiredPath)
        canvas.drawPath(offDesiredPath, paintArea)
        return bitmap
    }

    override fun getDesiredPathLength(): Float = pathLength

    constructor(context: Context) : super(context) {
        initDrawingView()
    }

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        initDrawingView()
    }

    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {
        initDrawingView()
    }

    override fun onSensorDisconnected(bmSensorManager: IBMSensorManager) {
        showToastMessage("Disconnected from: " + bmSensorManager)
    }

    override fun onSensorConnected(bmSensorManager: IBMSensorManager) {
        showToastMessage("Connected to: " + bmSensorManager)
    }

    lateinit var mPresenter: SensorDrawingViewViewContract.Presenter

    override fun setPresenter(sensorDrawingViewPresenter: SensorDrawingViewViewContract.Presenter) {
        this.mPresenter = sensorDrawingViewPresenter
    }

    override fun showToastMessage(message: String) {
        this.post { Toast.makeText(context, message, Toast.LENGTH_SHORT).show() }
    }

    var isMoving: Boolean by Delegates.observable(false, { prop, old, new ->
        if (old != new) {
            Timber.d("isMoving: $new")
            if (!new) {
                doZUPT()
            }
        }
    })

    override fun setIsMoving(isMoving: Boolean) {
        this.isMoving = isMoving
    }

    override fun setDegreesToNorth(degreesToTrueNorth: Float) {
        compassView.updateAngle(degreesToTrueNorth)
    }

    override fun invalidateView() {
        this.post {
            invalidate()
        }
    }

    fun setAspectRatio(aspectRatio: Float) {
        compassView.screenAspectRatio = aspectRatio
    }

    /**
     * Method that majes a list used for displayin some debug data.
     * Used only for debugging view. */
    fun getStatistics(): ArrayList<String> {
        listDebugMessages.clear()
        listDebugMessages.add("Distance from desired path: $currentDistanceFromDesiredPath")
        listDebugMessages.add("Linear Speed (magnitude) (m/s): $v0")
        listDebugMessages.add("Linear acc (magnitude) (m/s2): $a")
        listDebugMessages.add("Degree diff (avg): ${Math.abs(compassView.movingAverageAngleDiff.avg)}")
        listDebugMessages.add("Is rotating: ${compassView.isRotating}")
        listDebugMessages.add("Is moving: $isMoving")
        return listDebugMessages
    }


    fun drawBackground(canvas: Canvas) {
        //TODO deal with aspect ratio --> image gets distorted
        val rectSrc = Rect(0, 0, courtBackGround.width, courtBackGround.height)
        val rectDst = Rect(0, 0, canvas.width, canvas.height)
        canvas.drawBitmap(courtBackGround, rectSrc, rectDst, null)
    }


    val compassView: CompassView by lazy {
        CompassView(context)
    }

    /** Method being called on each frame. */
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        drawBackground(canvas)

        if (ViewUtils.isInDebugMode) {
            mPresenter.displayStats(getStatistics())
        }

        updateCurrentSegmentValues()

        compassView.drawCompass(canvas)

        canvas.drawPath(desiredPath, paintDesiredPath)

        if (isMoving) {
            updateSensorPath()
        }

        canvas.drawPath(sensorPath, paintSensorPath)
        canvas.drawCircle(actualEndPoint, CURRENT_LOCATION_RADIUS_PIXELS, paintCurrentLocation)
    }

    /** Property for keeping track of when user leaves the desired path.*/
    var isOffThePath by Delegates.observable(false, { _, old, new ->
        if (old == false && new == true) {
            leavingDesiredPath()
        } else if (old == true && new == false) {
            comingToThePath()
        }
    })

    private fun comingToThePath() {
        val currentDesiredPathEnd = PointF()
        pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
        val dist = Vector2D.distance(currentDesiredPathEnd, actualEndPoint)
        distanceCovered += dist.toInt()
        sensorPath.lineTo(actualEndPoint)
        offDesiredPath.lineTo(actualEndPoint)
    }

    private fun leavingDesiredPath() {
        Timber.d("leavingDesiredPath")
        val currentDesiredPathEnd = PointF()
        pathMeasure.getPointAtDistance(distanceCovered, currentDesiredPathEnd)
        offDesiredPath.moveTo(currentDesiredPathEnd)
    }

    var currentSegmentIndex: Int = 0
    var currentSegmentAngle: Double = 0.0

    private var isInRecordingMode: Boolean = false

    private var rotatingDisposable: Disposable? = null

    override fun onRecordingModeChange(inRecordingMode: Boolean) {
        isInRecordingMode = inRecordingMode
        if (isInRecordingMode) {
            rotatingDisposable = compassView.isRotatingObservable
                    .subscribe({ isRotating ->
                        if (isRotating) {
                            doZUPT()
                        }
                    })
        } else {
            rotatingDisposable?.dispose()
            rotatingDisposable = null
        }
    }

    /**
     * Main method for drawing sensor path.
     *
     * In charge of:
     *      checking how far user got in covering the path
     *      tracking when user goes off the path by measuring the distance from current segment
     *      recognizing when user gets back to the desired path
     *      adding points to sensor path
     *      adding points to error path in the background (used for exporting error area bitmap)
     *
     * */
    fun updateSensorPath() {
        if (currentSegmentIndex > pathSegmentsLengths.size - 1) {
            if (isInRecordingMode) {
                mPresenter.onDrillCompleted()
            }
            return
        }
        val tempNextPoint = getNextDrawPoint(actualEndPoint, accBasedMoves.last())
        if (tempNextPoint == OUT_OF_BOUNDS_POINT) {
            return
        }

        actualEndPoint = tempNextPoint

        if (isOffThePath) {
            sensorPath.lineTo(actualEndPoint)
            offDesiredPath.lineTo(actualEndPoint)
        } else {
            val distance = accBasedMoves.last().distance
            val nextPoint = PointF()
            val isPosExtracted = pathMeasure.getPointAtDistance(distanceCovered + distance, nextPoint)
//            Timber.d("${currentViewAngle} <- compass to View | current segment->  $currentSegmentAngle correction " +
//                    "$compassView")
            if (isPosExtracted && nextPoint.distanceTo(actualEndPoint) < DISTANCE_FROM_DESIRED_PATH_TOLERANCE) {
                sensorPath.lineTo(nextPoint)
                distanceCovered += distance
            }
        }

        currentDistanceFromDesiredPath = Geometry2D.distance(pathViewPoints, actualEndPoint, currentSegmentIndex)
    }

    /**
     * Updating current segment values.
     *
     * Based on distance covered we set current segment values. Distance covered is simply
     * compared to each segment end.
     * */
    fun updateCurrentSegmentValues() {
        pathSegmentsLengths.forEachIndexed { index, (length, angle) ->
            if (distanceCovered < length) {
                currentSegmentIndex = index
                currentSegmentAngle = angle
                return
            }
        }
        currentSegmentIndex = pathSegmentsLengths.size
    }

    /** Used for reseting values to default ones.*/
    override fun resetDrill() {
        movingAverageLinearAcc.forEach { it.reset() }

        mPrevReadingTimestamp = -1
        v0 = 0.0
        a = 0F
        distanceCovered = 0F
        currentDistanceFromDesiredPath = 0.0
        accBasedMoves.clear()
        sensorPath.reset()
        offDesiredPath.reset()

        initBeforeDrillStart()
    }

    /**
     * Gravity compensation implementation using low pass filter.
     *
     * [Android sensor low pass filter][https://developer.android.com/reference/android/hardware/SensorEvent.html#values]
     * */
    fun calculateLinearAccAndGravity(sample: BMSensorManager.AccData) {
        for (i in 0..2) {
            accReading = sample.data[i].toShort()
            gravity[i] = alpha * gravity[i] + (1 - alpha) * accReading

            val nextMAValue = if (compassView.isRotating) 0 else (accReading - gravity[i]).toInt()
            val avg = movingAverageLinearAcc[i].next(nextMAValue)
            linear_acceleration[i] = avg.toInt()
        }
    }

    /** This metho is in cahrage of adding current acceleration data to the already
     * accumulated ones.
     *
     * @param accData Acceleration data being read from sensor in last reading.
     * */
    override fun addAccData(accData: BMSensorManager.AccData) {
        if (mPrevReadingTimestamp == -1L) {
            mPrevReadingTimestamp = accData.timestamp
            return
        }

        val dt = (accData.timestamp - mPrevReadingTimestamp).toDouble() / 100

        calculateLinearAccAndGravity(accData)

        val squaresSumLinearAcc = (0..2)
                .map { linear_acceleration[it] / 1000f }
                .sumByDouble { (it * it).toDouble() }

        a = GRAVITY_EARTH * Math.sqrt(squaresSumLinearAcc).toFloat()

        val s = v0 * dt + a * dt * dt / 2
        if (isMoving && !compassView.isRotating) {
            val pixelDistance = ViewUtils.convertMetersToPixels(s.toFloat())
            accBasedMoves.add(Move(compassView.degreesToNorth, ACC_MULTIPLIER * pixelDistance))
        }
        v0 += a * dt

        mPrevReadingTimestamp = accData.timestamp
    }

    /** perform Zero update.
     * Set speed and acceleration values to 0 whenever zupt detected.
     * On each step and while rotation, we can assume that velocity and speed are zero.*/
    private fun doZUPT() {
        Timber.d("zupt performed")
        v0 = 0.0
        a = 0f
    }

    /**
     * Y Coordinates on android canvas are positive in - direction
     * */
    val startVec = floatArrayOf(0f, -1f)

    fun getNextDrawPoint(lastPoint: PointF, move: Move): PointF {
        val drawPoint = Vector2D.getDrawPoint(startVec, move.direction, move.distance, lastPoint)
        viewDimens.width
        if (drawPoint.x in VIEW_PADDING..viewDimens.width - VIEW_PADDING &&
                drawPoint.y in VIEW_PADDING..viewDimens.height - VIEW_PADDING) {
            return drawPoint
        } else {
            return OUT_OF_BOUNDS_POINT
        }
    }


    /**
     * Class used for saving each move generated by sensors.
     *
     * @param direction Angle of the direction where player is facing at this move.
     * @param distance Displacement for move in pixels.
     * */
    data class Move(var direction: Float, var distance: Float)
}

private fun PointF.isOutOfBounds(): Boolean {
    TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
}
